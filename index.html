<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gravity Maze</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-green: #00ff9d;
            --bg-dark: #050510;
        }
        body {
            overscroll-behavior: none;
            touch-action: none;
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-dark);
            overflow: hidden;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        
        /* --- UI & Styles Cyberpunk --- */
        .cyber-panel {
            background: rgba(10, 15, 30, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(0, 0, 0, 0.5);
            clip-path: polygon(
                0 10px, 10px 0, 
                100% 0, 100% calc(100% - 10px), 
                calc(100% - 10px) 100%, 
                0 100%
            );
        }

        .btn-cyber {
            background: linear-gradient(90deg, transparent 0%, rgba(0, 243, 255, 0.2) 50%, transparent 100%);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .btn-cyber:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        .text-glow { text-shadow: 0 0 10px currentColor; }
        .text-glow-red { text-shadow: 0 0 10px #ff0055; }

        /* --- Animations --- */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .animate-float { animation: float 4s ease-in-out infinite; }

        .scanline::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 243, 255, 0.05) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }
    </style>
</head>
<body class="h-screen w-screen relative text-white scanline select-none">

    <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>

    <div class="absolute inset-0 z-0 opacity-20 pointer-events-none" 
         style="background-image: radial-gradient(#00f3ff 1px, transparent 1px); background-size: 40px 40px;">
    </div>

    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black/90 transition-opacity duration-500">
        <div class="cyber-panel p-10 rounded-none max-w-md text-center mx-4 animate-float">
            <h1 class="text-6xl font-bold mb-2 text-cyan-400 text-glow tracking-tighter">NEO MAZE</h1>
            <div class="h-1 w-full bg-cyan-500 mb-6 shadow-[0_0_10px_#00f3ff]"></div>
            <p class="text-gray-300 mb-8 text-lg">Inclinez votre appareil pour guider l'orbe.</p>
            
            <button id="startBtn" class="w-full btn-cyber font-bold py-4 px-8 mb-4">
                INITIALISER LE SYSTÈME
            </button>
            <p class="text-xs text-gray-500 font-mono mt-4">
                [INPUT: GYROSCOPE / CLAVIER]
            </p>
        </div>
    </div>

    <div id="hud" class="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none hidden z-40 font-mono">
        <div>
            <div class="text-xs text-cyan-600 uppercase tracking-[0.2em]">Secteur</div>
            <div id="levelDisplay" class="text-4xl font-bold text-cyan-400 text-glow">01</div>
        </div>
        
        <div class="flex flex-col items-center">
            <div class="text-xs text-cyan-600 uppercase tracking-[0.2em]">Vies</div>
            <div id="livesContainer" class="flex gap-2 mt-1">
                </div>
        </div>

        <div class="text-right">
            <div class="text-xs text-cyan-600 uppercase tracking-[0.2em]">Chrono</div>
            <div id="timeDisplay" class="text-4xl font-bold text-white text-glow">0.0</div>
        </div>
    </div>

    <div id="endScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black/90 hidden">
        <div class="cyber-panel p-10 max-w-md text-center mx-4 border-t-4" id="endPanelBorder">
            <h2 id="endTitle" class="text-5xl font-bold mb-2 text-white text-glow">COMPLETE</h2>
            <p id="endMessage" class="text-xl text-gray-300 mb-8 font-mono">Données sauvegardées.</p>
            <button id="actionBtn" class="btn-cyber font-bold py-4 px-10 w-full">
                NIVEAU SUIVANT
            </button>
        </div>
    </div>

    <script>
        const CONFIG = {
            STORAGE_KEY: 'gravity_maze_save_v1',
            INITIAL_LIVES: 3,
            PHYSICS: {
                FRICTION: 0.95,
                SENSITIVITY: 0.9,
                MAX_TILT: 40, // Degrés max pris en compte
                COLLISION_RADIUS_FACTOR: 1.5, // Espace min entre obstacles
            },
            COLORS: {
                PLAYER: '#00f3ff',
                GOAL: '#00ff9d',
                OBSTACLE: '#ff0055',
                TRAIL: 'rgba(0, 243, 255, 0.3)'
            },
            ENTITIES: {
                PLAYER_RADIUS: 10,
                GOAL_RADIUS: 25
            }
        };

        const State = {
            level: 1,
            lives: CONFIG.INITIAL_LIVES,
            startTime: 0,
            isPlaying: false,
            animationFrame: null,
            input: { x: 0, y: 0 },
            
            // Entités
            player: { x: 0, y: 0, vx: 0, vy: 0, trail: [] },
            goal: { x: 0, y: 0, pulse: 0 },
            obstacles: []
        };

        // --- Références DOM ---
        const UI = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            screens: {
                start: document.getElementById('startScreen'),
                end: document.getElementById('endScreen'),
                hud: document.getElementById('hud')
            },
            display: {
                level: document.getElementById('levelDisplay'),
                time: document.getElementById('timeDisplay'),
                lives: document.getElementById('livesContainer'),
                endTitle: document.getElementById('endTitle'),
                endMessage: document.getElementById('endMessage'),
                endBorder: document.getElementById('endPanelBorder'),
                actionBtn: document.getElementById('actionBtn')
            }
        };


        // Initialisation du Canvas
        function resizeCanvas() {
            UI.canvas.width = window.innerWidth;
            UI.canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        /**
         * Charge la progression depuis le LocalStorage
         */
        function loadProgress() {
            const savedLevel = localStorage.getItem(CONFIG.STORAGE_KEY);
            if (savedLevel) {
                State.level = parseInt(savedLevel, 10);
            }
        }

        /**
         * Sauvegarde la progression
         */
        function saveProgress() {
            localStorage.setItem(CONFIG.STORAGE_KEY, State.level);
        }

        /**
         * Génère un niveau de manière procédurale
         */
        function initLevel(isRetry = false) {
            // Reset Joueur
            State.player.x = 60;
            State.player.y = 60;
            State.player.vx = 0;
            State.player.vy = 0;
            State.player.trail = [];

            // Reset Objectif
            State.goal.x = UI.canvas.width - 60;
            State.goal.y = UI.canvas.height - 60;

            // Si c'est un "retry" (perte de vie), on garde les mêmes obstacles
            // Sinon, on génère de nouveaux obstacles
            if (!isRetry) {
                generateObstacles();
            }

            // Démarrage
            State.startTime = Date.now();
            State.isPlaying = true;
            
            // Mise à jour UI
            updateHUD();
            UI.screens.hud.classList.remove('hidden');
            UI.screens.end.classList.add('hidden');
            
            if (State.animationFrame) cancelAnimationFrame(State.animationFrame);
            gameLoop();
        }

        function generateObstacles() {
            State.obstacles = [];
            const count = 4 + State.level * 2; // Difficulté croissante
            const minSpace = (CONFIG.ENTITIES.PLAYER_RADIUS * 2) * 1.5;
            
            let attempts = 0;
            const MAX_ATTEMPTS = 1000;

            while (State.obstacles.length < count && attempts < MAX_ATTEMPTS) {
                attempts++;
                
                const w = Math.random() * 120 + 50;
                const h = Math.random() * 120 + 50;
                const x = Math.random() * (UI.canvas.width - w);
                const y = Math.random() * (UI.canvas.height - h);

                // 1. Zone de sécurité (Départ & Arrivée)
                const distPlayer = Math.hypot(x - State.player.x, y - State.player.y);
                const distGoal = Math.hypot(x - State.goal.x, y - State.goal.y);
                
                if (distPlayer < 200 || distGoal < 200) continue;

                // 2. Vérification de chevauchement
                let overlap = false;
                for (let obs of State.obstacles) {
                    if (
                        x < obs.x + obs.w + minSpace &&
                        x + w + minSpace > obs.x &&
                        y < obs.y + obs.h + minSpace &&
                        y + h + minSpace > obs.y
                    ) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    State.obstacles.push({ x, y, w, h });
                }
            }
        }

        /**
         * Gestion des Contrôles (Clavier + Gyroscope)
         */
        function setupControls() {
            // Gyroscope
            window.addEventListener('deviceorientation', (e) => {
                if (!State.isPlaying) return;
                const max = CONFIG.PHYSICS.MAX_TILT;
                // Clamp values
                const xTilt = Math.max(-max, Math.min(max, e.gamma || 0));
                const yTilt = Math.max(-max, Math.min(max, e.beta || 0));
                
                State.input.x = xTilt / max;
                State.input.y = yTilt / max;
            });

            // Clavier
            const keys = {};
            window.addEventListener('keydown', e => keys[e.code] = true);
            window.addEventListener('keyup', e => keys[e.code] = false);

            // Fonction de polling pour le clavier (dans update)
            State.checkKeyboard = () => {
                if (window.DeviceOrientationEvent && window.orientation !== undefined) return; // Priorité au mobile si actif
                
                State.input.x = 0;
                State.input.y = 0;
                if (keys['ArrowRight']) State.input.x = 1;
                if (keys['ArrowLeft']) State.input.x = -1;
                if (keys['ArrowDown']) State.input.y = 1;
                if (keys['ArrowUp']) State.input.y = -1;
            };
        }

        /**
         * Mise à jour de la physique
         */
        function update() {
            State.checkKeyboard(); // Vérif clavier

            const p = State.player;
            
            // Vélocité
            p.vx += State.input.x * CONFIG.PHYSICS.SENSITIVITY;
            p.vy += State.input.y * CONFIG.PHYSICS.SENSITIVITY;
            p.vx *= CONFIG.PHYSICS.FRICTION;
            p.vy *= CONFIG.PHYSICS.FRICTION;
            
            p.x += p.vx;
            p.y += p.vy;

            // Gestion de la traînée (Trail)
            if (Math.abs(p.vx) + Math.abs(p.vy) > 0.5) {
                p.trail.push({ x: p.x, y: p.y, alpha: 1.0 });
            }
            p.trail.forEach(t => t.alpha -= 0.05);
            p.trail = p.trail.filter(t => t.alpha > 0);

            // Collisions Murs
            const r = CONFIG.ENTITIES.PLAYER_RADIUS;
            if (p.x - r < 0) { p.x = r; p.vx = 0; }
            if (p.x + r > UI.canvas.width) { p.x = UI.canvas.width - r; p.vx = 0; }
            if (p.y - r < 0) { p.y = r; p.vy = 0; }
            if (p.y + r > UI.canvas.height) { p.y = UI.canvas.height - r; p.vy = 0; }

            // Collisions Obstacles
            checkObstacleCollisions();

            // Condition de Victoire
            const distToGoal = Math.hypot(p.x - State.goal.x, p.y - State.goal.y);
            if (distToGoal < r + CONFIG.ENTITIES.GOAL_RADIUS) {
                handleWin();
            }

            // Mise à jour Timer UI
            UI.display.time.innerText = ((Date.now() - State.startTime) / 1000).toFixed(1);
        }

        function checkObstacleCollisions() {
            const p = State.player;
            const r = CONFIG.ENTITIES.PLAYER_RADIUS;

            for (let obs of State.obstacles) {
                // Trouver le point le plus proche sur le rectangle (clamp)
                const closestX = Math.max(obs.x, Math.min(p.x, obs.x + obs.w));
                const closestY = Math.max(obs.y, Math.min(p.y, obs.y + obs.h));

                const distX = p.x - closestX;
                const distY = p.y - closestY;
                
                // Si la distance est inférieure au rayon, collision
                if ((distX * distX + distY * distY) < (r * r)) {
                    handleDeath();
                    return;
                }
            }
        }

        /**
         * Rendu graphique
         */
        function draw() {
            const ctx = UI.ctx;
            ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);

            // 1. Dessiner la traînée
            State.player.trail.forEach(t => {
                ctx.beginPath();
                ctx.arc(t.x, t.y, CONFIG.ENTITIES.PLAYER_RADIUS * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 243, 255, ${t.alpha * 0.3})`;
                ctx.fill();
            });

            // 2. Dessiner les Obstacles
            ctx.shadowBlur = 15;
            ctx.shadowColor = CONFIG.COLORS.OBSTACLE;
            ctx.strokeStyle = CONFIG.COLORS.OBSTACLE;
            ctx.lineWidth = 2;

            State.obstacles.forEach(obs => {
                ctx.fillStyle = 'rgba(255, 0, 85, 0.15)';
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                
                // Détails tech aux coins
                ctx.fillStyle = CONFIG.COLORS.OBSTACLE;
                ctx.fillRect(obs.x, obs.y, 4, 4);
                ctx.fillRect(obs.x + obs.w - 4, obs.y + obs.h - 4, 4, 4);
            });

            // 3. Dessiner l'Objectif
            State.goal.pulse += 0.05;
            const pulseSize = Math.sin(State.goal.pulse) * 5;
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = CONFIG.COLORS.GOAL;
            
            // Anneau externe
            ctx.beginPath();
            ctx.arc(State.goal.x, State.goal.y, CONFIG.ENTITIES.GOAL_RADIUS + pulseSize, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 255, 157, 0.5)';
            ctx.stroke();

            // Cœur
            ctx.beginPath();
            ctx.arc(State.goal.x, State.goal.y, CONFIG.ENTITIES.GOAL_RADIUS * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = CONFIG.COLORS.GOAL;
            ctx.fill();

            // 4. Dessiner le Joueur
            ctx.shadowBlur = 20;
            ctx.shadowColor = CONFIG.COLORS.PLAYER;
            ctx.beginPath();
            ctx.arc(State.player.x, State.player.y, CONFIG.ENTITIES.PLAYER_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = CONFIG.COLORS.PLAYER;
            ctx.fill();
            
            // Point blanc central (effet noyau chaud)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(State.player.x, State.player.y, CONFIG.ENTITIES.PLAYER_RADIUS * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function gameLoop() {
            if (State.isPlaying) {
                update();
                draw();
                State.animationFrame = requestAnimationFrame(gameLoop);
            }
        }

        function updateHUD() {
            // Mise à jour du texte Niveau
            const lvl = State.level;
            UI.display.level.innerText = lvl < 10 ? '0' + lvl : lvl;

            // Mise à jour visuelle des Vies (Cœurs/Carrés)
            UI.display.lives.innerHTML = '';
            for (let i = 0; i < State.lives; i++) {
                const heart = document.createElement('div');
                heart.className = 'w-4 h-4 bg-red-500 shadow-[0_0_10px_#ff0055] transform rotate-45';
                UI.display.lives.appendChild(heart);
            }
        }

        function handleWin() {
            State.isPlaying = false;
            UI.screens.hud.classList.add('hidden');
            
            // Logique de progression
            State.level++;
            saveProgress();

            // UI Victoire
            UI.display.endTitle.innerText = `SECTEUR ${State.level - 1} PURIFIÉ`;
            UI.display.endTitle.className = "text-5xl font-bold mb-2 text-cyan-400 text-glow";
            UI.display.endBorder.style.borderColor = CONFIG.COLORS.PLAYER;
            UI.display.endMessage.innerText = `Temps: ${((Date.now() - State.startTime) / 1000).toFixed(2)}s`;
            
            UI.display.actionBtn.innerText = "NIVEAU SUIVANT";
            UI.display.actionBtn.onclick = () => initLevel(false); // Nouveau niveau
            
            UI.screens.end.classList.remove('hidden');
        }

        function handleDeath() {
            State.isPlaying = false;
            UI.screens.hud.classList.add('hidden');
            
            State.lives--;

            if (State.lives > 0) {
                // Perte de vie simple
                showEndScreen(
                    "ÉCHEC CRITIQUE",
                    `Collision détectée. Vies restantes : ${State.lives}`,
                    "text-red-500 text-glow-red",
                    CONFIG.COLORS.OBSTACLE,
                    "RÉINITIALISER",
                    () => initLevel(true) // Retry (même niveau)
                );
            } else {
                // Game Over total
                showEndScreen(
                    "SYSTÈME HORS LIGNE",
                    "Toutes les vies ont été perdues.",
                    "text-red-500 text-glow-red",
                    CONFIG.COLORS.OBSTACLE,
                    "REBOOT SYSTÈME",
                    () => {
                        // Reset complet
                        State.level = 1;
                        State.lives = CONFIG.INITIAL_LIVES;
                        saveProgress();
                        initLevel(false);
                    }
                );
            }
        }

        function showEndScreen(title, message, titleClass, borderColor, btnText, action) {
            UI.display.endTitle.innerText = title;
            UI.display.endTitle.className = `text-5xl font-bold mb-2 ${titleClass}`;
            UI.display.endMessage.innerText = message;
            UI.display.endBorder.style.borderColor = borderColor;
            
            UI.display.actionBtn.innerText = btnText;
            UI.display.actionBtn.onclick = action;
            
            UI.screens.end.classList.remove('hidden');
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupControls();
            loadProgress();
            
            const startBtn = document.getElementById('startBtn');
            
            startBtn.addEventListener('click', async () => {
                // Demande de permission pour iOS 13+
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const response = await DeviceOrientationEvent.requestPermission();
                        if (response !== 'granted') {
                            alert("Permission gyroscope refusée. Utilisez le clavier.");
                        }
                    } catch (e) { console.error(e); }
                }

                UI.screens.start.classList.add('opacity-0');
                setTimeout(() => {
                    UI.screens.start.classList.add('hidden');
                    initLevel();
                }, 500);
            });
        });

    </script>
</body>
</html>
