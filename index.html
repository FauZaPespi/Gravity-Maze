<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cordova Sensor Demo: Gravity Maze</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overscroll-behavior: none;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen w-screen relative">

    <!-- Game Canvas -->
    <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>

    <!-- UI Overlay: Start / Permission Screen -->
    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-gray-900 bg-opacity-95 transition-opacity duration-500">
        <div class="glass-panel p-8 rounded-2xl max-w-sm text-center mx-4">
            <h1 class="text-4xl font-bold mb-2 text-cyan-400">Gravity Maze</h1>
            <p class="text-gray-300 mb-6">Tilt your phone to guide the blue orb to the green portal.</p>
            
            <div class="space-y-4">
                <button id="startBtn" class="w-full bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition hover:scale-105 active:scale-95">
                    Start Game
                </button>
                <p class="text-xs text-gray-500 mt-4">
                    Desktop users: Use Arrow Keys.<br>
                    iOS users: Requires permission for motion sensors.
                </p>
            </div>
        </div>
    </div>

    <!-- UI Overlay: HUD -->
    <div id="hud" class="absolute top-0 left-0 w-full p-4 flex justify-between items-start pointer-events-none hidden z-40">
        <div>
            <div class="text-sm text-gray-400 uppercase tracking-wider">Level</div>
            <div id="levelDisplay" class="text-2xl font-bold text-white">1</div>
        </div>
        <div class="text-right">
            <div class="text-sm text-gray-400 uppercase tracking-wider">Time</div>
            <div id="timeDisplay" class="text-2xl font-bold text-white">0.0s</div>
        </div>
    </div>

    <!-- UI Overlay: Game Over / Win -->
    <div id="endScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black bg-opacity-80 hidden">
        <div class="glass-panel p-8 rounded-2xl max-w-sm text-center mx-4">
            <h2 id="endTitle" class="text-3xl font-bold mb-2 text-white">Level Complete!</h2>
            <p id="endMessage" class="text-gray-300 mb-6">Great job!</p>
            <button id="nextLevelBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transition transform hover:scale-105">
                Next Level
            </button>
        </div>
    </div>

    <script>
        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const hud = document.getElementById('hud');
        const endScreen = document.getElementById('endScreen');
        const levelDisplay = document.getElementById('levelDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const nextLevelBtn = document.getElementById('nextLevelBtn');

        let gameState = 'START'; // START, PLAYING, END
        let animationFrameId;
        let startTime = 0;
        let currentLevel = 1;

        // Physics variables
        const friction = 0.96;
        const sensitivity = 0.8; // How sensitive the tilt is
        
        // Input state (Tilt or Keyboard)
        let input = { x: 0, y: 0 };
        
        // Game Objects
        let player = {
            x: 0, y: 0,
            radius: 12,
            vx: 0, vy: 0,
            color: '#22d3ee' // cyan-400
        };

        let goal = {
            x: 0, y: 0,
            radius: 20,
            color: '#4ade80', // green-400
            pulse: 0
        };

        let obstacles = [];

        // --- Initialization ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function initLevel(level) {
            // Reset Player
            player.x = 50;
            player.y = 50;
            player.vx = 0;
            player.vy = 0;

            // Generate Goal (always far from player)
            goal.x = canvas.width - 50;
            goal.y = canvas.height - 50;

            // Generate Obstacles based on level difficulty
            obstacles = [];
            const obstacleCount = 3 + level * 2;
            
            for(let i = 0; i < obstacleCount; i++) {
                const w = Math.random() * 100 + 40;
                const h = Math.random() * 100 + 40;
                let validPos = false;
                let ox, oy;

                // Simple collision avoidance for spawn
                let attempts = 0;
                while(!validPos && attempts < 100) {
                    ox = Math.random() * (canvas.width - w);
                    oy = Math.random() * (canvas.height - h);
                    
                    // Check distance from player and goal
                    const distPlayer = Math.hypot(ox - player.x, oy - player.y);
                    const distGoal = Math.hypot(ox - goal.x, oy - goal.y);
                    
                    if (distPlayer > 150 && distGoal > 150) {
                        validPos = true;
                    }
                    attempts++;
                }

                if(validPos) {
                    obstacles.push({ x: ox, y: oy, w: w, h: h });
                }
            }

            startTime = Date.now();
            gameState = 'PLAYING';
            levelDisplay.innerText = level;
            hud.classList.remove('hidden');
            endScreen.classList.add('hidden');
            
            cancelAnimationFrame(animationFrameId);
            loop();
        }

        // --- Input Handling ---

        // 1. Device Orientation (Mobile)
        function handleOrientation(event) {
            if (gameState !== 'PLAYING') return;
            
            // Gamma: Left/Right tilt (-90 to 90)
            // Beta: Front/Back tilt (-180 to 180)
            
            // Clamp values to avoid extreme speeds
            const xTilt = Math.max(-45, Math.min(45, event.gamma || 0));
            const yTilt = Math.max(-45, Math.min(45, event.beta || 0));

            // Normalize to -1 to 1 range
            input.x = xTilt / 45; 
            input.y = yTilt / 45;
        }

        // 2. Keyboard (Desktop Fallback)
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        function processKeyboardInput() {
            // Only override sensor input if keys are pressed
            if (keys.ArrowRight) input.x = 1;
            else if (keys.ArrowLeft) input.x = -1;
            else if (!window.DeviceOrientationEvent) input.x = 0; // Reset only if no sensor

            if (keys.ArrowDown) input.y = 1;
            else if (keys.ArrowUp) input.y = -1;
            else if (!window.DeviceOrientationEvent) input.y = 0;
        }

        // --- Core Game Loop ---

        function update() {
            processKeyboardInput();

            // Apply acceleration based on input
            player.vx += input.x * sensitivity;
            player.vy += input.y * sensitivity;

            // Apply friction
            player.vx *= friction;
            player.vy *= friction;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // Wall Collisions
            if (player.x - player.radius < 0) { player.x = player.radius; player.vx *= -0.5; }
            if (player.x + player.radius > canvas.width) { player.x = canvas.width - player.radius; player.vx *= -0.5; }
            if (player.y - player.radius < 0) { player.y = player.radius; player.vy *= -0.5; }
            if (player.y + player.radius > canvas.height) { player.y = canvas.height - player.radius; player.vy *= -0.5; }

            // Obstacle Collisions
            obstacles.forEach(obs => {
                // Closest point on rectangle to circle center
                let testX = player.x;
                let testY = player.y;

                if (player.x < obs.x) testX = obs.x;
                else if (player.x > obs.x + obs.w) testX = obs.x + obs.w;

                if (player.y < obs.y) testY = obs.y;
                else if (player.y > obs.y + obs.h) testY = obs.y + obs.h;

                let distX = player.x - testX;
                let distY = player.y - testY;
                let distance = Math.sqrt((distX*distX) + (distY*distY));

                if (distance <= player.radius) {
                    // Collision resolution - Bounce back simple
                    const angle = Math.atan2(distY, distX);
                    const pushOut = player.radius - distance + 1;
                    
                    player.x += Math.cos(angle) * pushOut;
                    player.y += Math.sin(angle) * pushOut;

                    // Dampen velocity heavily on collision
                    player.vx *= -0.6;
                    player.vy *= -0.6;
                }
            });

            // Goal Detection
            const dx = player.x - goal.x;
            const dy = player.y - goal.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < player.radius + goal.radius) {
                winLevel();
            }

            // Update Time
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            timeDisplay.innerText = elapsed + 's';
        }

        function draw() {
            // Clear screen
            ctx.fillStyle = '#111827'; // gray-900
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid (Decoration)
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 1;
            const gridSize = 40;
            for(let x=0; x<canvas.width; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for(let y=0; y<canvas.height; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width, y); ctx.stroke(); }

            // Draw Obstacles
            ctx.fillStyle = '#ef4444'; // red-500
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ef4444';
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                // Bevel effect
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(obs.x, obs.y, obs.w, 4);
                ctx.fillStyle = '#ef4444';
            });
            ctx.shadowBlur = 0;

            // Draw Goal
            goal.pulse += 0.05;
            const pulseSize = Math.sin(goal.pulse) * 4;
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.radius + pulseSize, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(74, 222, 128, 0.3)'; // Outer glow
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.radius, 0, Math.PI * 2);
            ctx.fillStyle = goal.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = goal.color;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = player.color;
            ctx.fill();
            
            // Reflection on ball
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            ctx.arc(player.x - 4, player.y - 4, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function loop() {
            if (gameState === 'PLAYING') {
                update();
                draw();
                animationFrameId = requestAnimationFrame(loop);
            }
        }

        function winLevel() {
            gameState = 'WON';
            hud.classList.add('hidden');
            document.getElementById('endTitle').innerText = `Level ${currentLevel} Cleared!`;
            document.getElementById('endMessage').innerText = `Time: ${((Date.now() - startTime) / 1000).toFixed(2)}s`;
            endScreen.classList.remove('hidden');
        }

        // --- Event Listeners ---

        document.getElementById('startBtn').addEventListener('click', async () => {
            // iOS 13+ Permission Request
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    } else {
                        alert("Permission denied. Game will rely on keyboard controls.");
                    }
                } catch (e) {
                    console.error(e);
                }
            } else {
                // Non-iOS 13+ devices
                window.addEventListener('deviceorientation', handleOrientation);
            }

            startScreen.classList.add('opacity-0');
            setTimeout(() => {
                startScreen.classList.add('hidden');
                initLevel(currentLevel);
            }, 500);
        });

        nextLevelBtn.addEventListener('click', () => {
            currentLevel++;
            initLevel(currentLevel);
        });

    </script>
</body>
</html>
