Voici une version améliorée de votre jeu. J'ai intégré toutes vos demandes :

1.  **Mort au contact :** Toucher un bloc rouge déclenche maintenant un "Game Over" immédiat au lieu d'un rebond.
2.  **Génération intelligente :** J'ai réécrit l'algorithme de création du niveau. Il vérifie maintenant que les nouveaux blocs ne chevauchent pas les anciens et qu'il y a toujours un espace suffisant (basé sur la taille de la balle \* 1.5) entre eux pour circuler.
3.  **Design & Animations :** J'ai supprimé le look "par défaut" de Tailwind. J'ai ajouté :
      * Une police futuriste (Rajdhani).
      * Un système de particules (traînée) derrière la balle pour l'effet de vitesse.
      * Des effets de néon et de lueur (Glow).
      * Des animations CSS pour l'apparition des menus.

Voici le code complet, prêt à être utilisé :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gravity Maze - Neon Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-green: #00ff9d;
            --bg-dark: #050510;
        }
        body {
            overscroll-behavior: none;
            touch-action: none;
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-dark);
            overflow: hidden;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        
        /* UI Styling "Non-Standard" */
        .cyber-panel {
            background: rgba(10, 15, 30, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(0, 0, 0, 0.5);
            clip-path: polygon(
                0 10px, 10px 0, 
                100% 0, 100% calc(100% - 10px), 
                calc(100% - 10px) 100%, 
                0 100%
            );
        }

        .btn-cyber {
            background: linear-gradient(90deg, transparent 0%, rgba(0, 243, 255, 0.2) 50%, transparent 100%);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .btn-cyber:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        .text-glow {
            text-shadow: 0 0 10px currentColor;
        }

        /* Animations */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .animate-float {
            animation: float 4s ease-in-out infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scanline::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 243, 255, 0.05) 50%);
            background-size: 100% 4px;
            pointer-events: none;
        }
    </style>
</head>
<body class="h-screen w-screen relative text-white scanline">

    <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>

    <div class="absolute inset-0 z-0 opacity-20 pointer-events-none" style="background-image: radial-gradient(#00f3ff 1px, transparent 1px); background-size: 40px 40px;"></div>

    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black bg-opacity-90 transition-opacity duration-500">
        <div class="cyber-panel p-10 rounded-none max-w-md text-center mx-4 animate-float">
            <h1 class="text-6xl font-bold mb-2 text-cyan-400 text-glow tracking-tighter">NEO MAZE</h1>
            <div class="h-1 w-full bg-cyan-500 mb-6 shadow-[0_0_10px_#00f3ff]"></div>
            <p class="text-gray-300 mb-8 text-lg">Inclinez pour survivre. Évitez les zones rouges.</p>
            
            <button id="startBtn" class="w-full btn-cyber font-bold py-4 px-8 mb-4 clip-path-btn">
                INITIALISER LE SYSTÈME
            </button>
            <p class="text-xs text-gray-500 font-mono mt-4">
                [INPUT DETECTED: GYROSCOPE / KEYBOARD]
            </p>
        </div>
    </div>

    <div id="hud" class="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none hidden z-40 font-mono">
        <div>
            <div class="text-xs text-cyan-600 uppercase tracking-[0.2em]">Secteur</div>
            <div id="levelDisplay" class="text-4xl font-bold text-cyan-400 text-glow">01</div>
        </div>
        <div class="text-right">
            <div class="text-xs text-cyan-600 uppercase tracking-[0.2em]">Chrono</div>
            <div id="timeDisplay" class="text-4xl font-bold text-white text-glow">0.0</div>
        </div>
    </div>

    <div id="endScreen" class="absolute inset-0 flex flex-col items-center justify-center z-50 bg-black bg-opacity-90 hidden">
        <div class="cyber-panel p-10 max-w-md text-center mx-4 border-t-4 border-t-current" id="endPanelBorder">
            <h2 id="endTitle" class="text-5xl font-bold mb-2 text-white text-glow">COMPLETE</h2>
            <p id="endMessage" class="text-xl text-gray-300 mb-8 font-mono">Données sauvegardées.</p>
            <button id="actionBtn" class="btn-cyber font-bold py-4 px-10 w-full">
                NIVEAU SUIVANT
            </button>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const hud = document.getElementById('hud');
        const endScreen = document.getElementById('endScreen');
        const levelDisplay = document.getElementById('levelDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const actionBtn = document.getElementById('actionBtn');
        const endTitle = document.getElementById('endTitle');
        const endPanelBorder = document.getElementById('endPanelBorder');

        let gameState = 'START'; // START, PLAYING, END
        let animationFrameId;
        let startTime = 0;
        let currentLevel = 1;
        let isGameOver = false;

        // Physics variables
        const friction = 0.95; // Slightly more slippery
        const sensitivity = 0.9; 
        
        let input = { x: 0, y: 0 };
        
        let player = {
            x: 0, y: 0,
            radius: 10, // Slightly smaller for precision
            vx: 0, vy: 0,
            color: '#00f3ff',
            trail: []
        };

        let goal = {
            x: 0, y: 0,
            radius: 25,
            color: '#00ff9d',
            pulse: 0
        };

        let obstacles = [];

        // --- Resize ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Game Logic ---

        function initLevel(level) {
            // Reset Player
            player.x = 60;
            player.y = 60;
            player.vx = 0;
            player.vy = 0;
            player.trail = [];

            // Goal Position
            goal.x = canvas.width - 60;
            goal.y = canvas.height - 60;

            // Generate Obstacles
            // Logic: No overlaps, Maintain Spacing > player.radius * 1.5 * 2 (diameter reference) + wiggle room
            obstacles = [];
            const obstacleCount = 4 + level * 2;
            const minSpacing = (player.radius * 2) * 1.5; // La demande: taille balle * 1.5
            
            let attempts = 0;
            const maxAttempts = 1000;

            while(obstacles.length < obstacleCount && attempts < maxAttempts) {
                attempts++;
                
                const w = Math.random() * 120 + 50;
                const h = Math.random() * 120 + 50;
                const ox = Math.random() * (canvas.width - w);
                const oy = Math.random() * (canvas.height - h);

                // Create temp rect
                const newObs = { x: ox, y: oy, w: w, h: h };

                // 1. Check Safe Zone around Player & Goal
                const distPlayer = Math.hypot(ox - player.x, oy - player.y);
                const distGoal = Math.hypot(ox - goal.x, oy - goal.y);
                if (distPlayer < 200 || distGoal < 200) continue;

                // 2. Check overlap with other obstacles WITH spacing
                let overlap = false;
                for (let obs of obstacles) {
                    // Check intersection with padding
                    if (
                        ox < obs.x + obs.w + minSpacing &&
                        ox + w + minSpacing > obs.x &&
                        oy < obs.y + obs.h + minSpacing &&
                        oy + h + minSpacing > obs.y
                    ) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    obstacles.push(newObs);
                }
            }

            startTime = Date.now();
            gameState = 'PLAYING';
            isGameOver = false;
            levelDisplay.innerText = level < 10 ? '0'+level : level;
            hud.classList.remove('hidden');
            endScreen.classList.add('hidden');
            
            cancelAnimationFrame(animationFrameId);
            loop();
        }

        // --- Input ---
        function handleOrientation(event) {
            if (gameState !== 'PLAYING') return;
            const xTilt = Math.max(-40, Math.min(40, event.gamma || 0));
            const yTilt = Math.max(-40, Math.min(40, event.beta || 0));
            input.x = xTilt / 40; 
            input.y = yTilt / 40;
        }

        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        function processInput() {
            if (keys.ArrowRight) input.x = 1;
            else if (keys.ArrowLeft) input.x = -1;
            else if (!window.DeviceOrientationEvent) input.x = 0;

            if (keys.ArrowDown) input.y = 1;
            else if (keys.ArrowUp) input.y = -1;
            else if (!window.DeviceOrientationEvent) input.y = 0;
        }

        // --- Core Loop ---
        function update() {
            processInput();

            player.vx += input.x * sensitivity;
            player.vy += input.y * sensitivity;
            player.vx *= friction;
            player.vy *= friction;
            player.x += player.vx;
            player.y += player.vy;

            // Trail Logic
            if(Math.abs(player.vx) + Math.abs(player.vy) > 0.5) {
                player.trail.push({x: player.x, y: player.y, alpha: 1.0});
            }
            // Update trail
            player.trail.forEach(t => t.alpha -= 0.05);
            player.trail = player.trail.filter(t => t.alpha > 0);

            // Wall Collisions
            if (player.x - player.radius < 0) { player.x = player.radius; player.vx = 0; }
            if (player.x + player.radius > canvas.width) { player.x = canvas.width - player.radius; player.vx = 0; }
            if (player.y - player.radius < 0) { player.y = player.radius; player.vy = 0; }
            if (player.y + player.radius > canvas.height) { player.y = canvas.height - player.radius; player.vy = 0; }

            // Obstacle Collisions (GAME OVER)
            for(let obs of obstacles) {
                let testX = player.x;
                let testY = player.y;

                if (player.x < obs.x) testX = obs.x;
                else if (player.x > obs.x + obs.w) testX = obs.x + obs.w;

                if (player.y < obs.y) testY = obs.y;
                else if (player.y > obs.y + obs.h) testY = obs.y + obs.h;

                let distX = player.x - testX;
                let distY = player.y - testY;
                let distance = Math.sqrt((distX*distX) + (distY*distY));

                if (distance <= player.radius) {
                    gameOver();
                    return; // Stop update
                }
            }

            // Win Condition
            const dist = Math.hypot(player.x - goal.x, player.y - goal.y);
            if (dist < player.radius + goal.radius) {
                levelComplete();
            }

            // HUD
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            timeDisplay.innerText = elapsed;
        }

        function draw() {
            // Clear with semi-transparent black for motion blur effect if desired, 
            // but sticking to clean clear for performance
            ctx.clearRect(0,0,canvas.width, canvas.height);

            // Draw Trail
            player.trail.forEach(t => {
                ctx.beginPath();
                ctx.arc(t.x, t.y, player.radius * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 243, 255, ${t.alpha * 0.3})`;
                ctx.fill();
            });

            // Draw Obstacles (Neon Red)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff0055';
            ctx.fillStyle = 'rgba(255, 0, 85, 0.15)'; // inner fill
            ctx.strokeStyle = '#ff0055'; // border
            ctx.lineWidth = 2;
            
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                
                // Tech decoration on block
                ctx.fillStyle = '#ff0055';
                ctx.fillRect(obs.x, obs.y, 4, 4);
                ctx.fillRect(obs.x + obs.w - 4, obs.y + obs.h - 4, 4, 4);
                ctx.fillStyle = 'rgba(255, 0, 85, 0.15)'; // reset fill
            });

            // Draw Goal (Neon Green)
            goal.pulse += 0.05;
            const pulseSize = Math.sin(goal.pulse) * 5;
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ff9d';
            
            // Outer Ring
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.radius + pulseSize, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 255, 157, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Core
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.radius * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = '#00ff9d';
            ctx.fill();

            // Draw Player (Neon Blue)
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00f3ff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00f3ff';
            ctx.fill();
            
            // Player Core (white hot)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function loop() {
            if (gameState === 'PLAYING') {
                update();
                draw();
                if (gameState === 'PLAYING') animationFrameId = requestAnimationFrame(loop);
            }
        }

        function levelComplete() {
            gameState = 'WON';
            hud.classList.add('hidden');
            
            endTitle.innerText = `SECTEUR ${currentLevel < 10 ? '0'+currentLevel : currentLevel} PURIFIÉ`;
            endTitle.classList.remove('text-red-500');
            endTitle.classList.add('text-cyan-400');
            endPanelBorder.style.borderColor = '#00f3ff';
            
            document.getElementById('endMessage').innerText = `Temps d'exécution: ${((Date.now() - startTime) / 1000).toFixed(2)}s`;
            
            actionBtn.innerText = "NIVEAU SUIVANT";
            actionBtn.onclick = () => {
                currentLevel++;
                initLevel(currentLevel);
            };
            
            endScreen.classList.remove('hidden');
        }

        function gameOver() {
            gameState = 'LOSE';
            hud.classList.add('hidden');
            
            endTitle.innerText = "ÉCHEC CRITIQUE";
            endTitle.classList.remove('text-cyan-400');
            endTitle.classList.add('text-red-500');
            endPanelBorder.style.borderColor = '#ff0055';

            document.getElementById('endMessage').innerText = "Collision détectée. Système compromis.";
            
            actionBtn.innerText = "RÉINITIALISER";
            actionBtn.onclick = () => {
                initLevel(currentLevel); // Restart same level
            };

            endScreen.classList.remove('hidden');
        }

        // --- Init ---
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    }
                } catch (e) { console.error(e); }
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }

            startScreen.classList.add('opacity-0');
            setTimeout(() => {
                startScreen.classList.add('hidden');
                initLevel(currentLevel);
            }, 500);
        });

    </script>
</body>
</html>
```
